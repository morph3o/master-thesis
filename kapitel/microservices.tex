\section{Microservices}

Microservices is a software architecture is usually linked to Martin Fowler in its article \cite{Fowler2014}. It is an architectural styles that aim to develop applications as a suite of small services independently of each other. Each of this services runs in its process and they communicate with lightweight mechanisms (e.g. HTTP resource API). These services are built around business capabilities and independently deployed by fully automated deployment machinery. Also there is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies \cite{Fowler2014}.

This architectural style emerges as a solution to the monolithic style due to its problems. An application built using monolithic architectural style is considered as a single unit with normally three main parts (figure \ref{}): a client-side user interface (i.e. HTML, CSS, JavaScript running on user's machine), a database and a server-side application. The latter is a monolith as it handles HTTP request, execute domain logic, retrieve and update data from the database, and populates and/or select the HTML views sent to the client-side. As it is a single logical executable, any changes made in the system, no matter the size of it, require a build and a deploy of the whole server-side application. It is hard to keep a good modular structure, making it harder to keep changes that must affect one module within that module. Also it is hard to scale as it is necessary to scale the entire application rather than parts of it requiring greater resources. These problems are causing frustrations on people that are using this style, specially nowadays when applications are deployed to the cloud, leading to the microservices architectural style.

\subsection{Characteristics of a Microservice Architecture}
In the work of Fowler and Lewis \cite{Fowler2014} described a list of common characteristic of applications built using microservice architectural style. It is important to point out that all the applications using this style must confirm every characteristic of this list.

\begin{description}[style=nextline]
\item[Componentization via Services] \hfill \
First of all it is important to explain the differences between libraries and services as the primary way of componentizing is by breking down software into services. On the one hand libraries are components that are linked into a application and called using in-memory function calls. On the other hand services are out-of-process components which communicates with a mechanism such as a web service request, or remote procedure call \cite{Fowler2014}.

Splitting a software into services brings benefits such as services as components are independently deployable making it easy for changes, or services have more explicit component interfaces by using explicit remote call mechanisms. 
\item[Organized around Business Capabilities] \hfill \
Normally in monolithic applications the development teams are divided by technology layers such as front-end team, server-side team and database team. However when team are divided in this way, even simple changes can lead to a cross-team project taking time and budgetary approval.

In Microservices approach this is taken in a different way by dividing the application into services organized around business capability. Thus services involve all needed for that business area, including user-interface (UI), database, business logic, and any other external collaboration. Therefore each teams are cross-functional, including the full range of skills required for the development of it.
\item[Products not Projects] \hfill \
Usually software development follows a project model where the objective is to deliver some piece of software which, when it is done, it is delivered to a maintenance team and the development team is disbanded.

Microservices approach follows the product model instead of project model. In the product model the development team takes full responsibility of the software, in other words it owns the product. This results in day-to-day contact of the developers with the users as they have to take on at least some of the support. Moreover this mentality ties in with the linkage to business capabilities as the focus is on how the software can assist its users to enhance the capabilities instead on put the focus on a list of functionality.
\item[Smart endpoints and dumb pipes] \hfill \
Microservices use the approach of smart endpoint and dumb pipes. Instead of putting so much smart into the communication mechanism itself, microservices approach aim to be as decoupled and as cohesive as possible. In other word, a microservice works as a black-box which receives a request, applies a logic, and produces a response. Usually two protocols are used, HTTP request-reponse with resource API's and lightweight messaging (e.g. RabbitMQ, ZeroMQ).
\item[Decentralized Governance] \hfill \
Using a centralized approach brings consequences such as standardise on single technology which keeps the team to use the right tool for the job. In contrast to that microservices approach allows to use use the technology that fit the requirements best. For instance, if NodeJS is more appropriate for a service than Java there will not problem choosing it.
\item[Decentralized Data Management] \hfill \
Microservices approach prefer letting each service manage its own database, either different instances of the same database technology, or entirely different database systems - an approach called Polyglot Persistence \cite{Leberknight2015}. 

Although this approach has some implications for managing updates or increment of complexity, the benefits are worth it. The common approach to solve the former implication is using transactions but implement it in services is difficult, that is why microservice architectures emphasize transactionless coordination between services, assuming that consistency may be only eventual consistency and problems are dealt with by compensation operations. This is useful in order to respond quickly to demand. In spite of the fact that by using different technologies increases the complexity, it allows the teams to solve the problem with the right tool. For instance if a service needs to just retrieve pages by looking up its ID, a key-value database is more suitable than a relational database. Moreover, as many NoSQL databases are designed to operate over clusters, they can tackle larger volumes of traffic and data which is harder with vertical scaling \cite{Fowler2011}.
\item[Design for failure] \hfill \
As a consequence of using microservice architecture, is that applications need to be designed so that they can tolerate the failure of services. As any service call could fail due to unavailability of the supplier service, the client service must respond as neat as possible.

Although this can be considered as a disadvantage in comparison to monolithic approach, using good monitoring and logging mechanism would help to overcome this. For instance a dashboard which display the status of the different services, current throughput, and latency would help to react in case one or more services go offline.
\end{description}

In conclusion, although microservices architectural style comes with many benefits, it also comes with several difficulties. By splitting up an application into services, we can simplify and speed up the release process, use the right tool for a job, or focus in how to assist better the user instead of a set of functionality. However we have to worry about changes to one service breaking its costumer, or deal with the increment of complexity.

It is important to consider that this style is not a silver bullet. As Fowler described in his blog post \cite{Fowler2014}, the core of The Guardian website \footnote{The Guardian: \url{https://www.theguardian.com/} (accessed: 04.02.2017).} was built as a monolith, however every new feature has been added as a microservice that uses the core's API.