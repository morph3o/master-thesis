\chapter{Introduction}
\label{chap:introduction}
Building software using already existent components is nothing new. During the 1960s Douglas MacIlroy came up with a vision of a software system composed of components, in which one basically puts different pieces (components), that already exist, together in order to form the system that is being built. Over the following 50 years of MacIlroy's vision, the IT industry has tried continuously to improve the speed and simultaneously reduce the cost of development by reusing software, however this vision is still far from being today's reality.

This process has attracted the attention of the industry due to its alleged benefits. Reduction of redundancies, reduction of cost, quality improvements, and fostering innovation are some of the benefits that come with reusing software. Unfortunately this is not an easy task.

The adoption of suitable reuse strategies is rather challenging as it takes place in multifaceted environments which incorporate aspects spanning from technical to organizational at different levels of abstractions \cite{Bauer2016}. In general the challenges can be divided in two groups: (1) organizational and (2) technical \cite{Hummel2013,Bauer2016}. In the former, problems such as organizational structure, inertia, knowledge, management, among others might affect the success of the implementation of this practice. For the latter, four core problems have been identified in the literature to implement a sustainable reuse repository: the repository problem \cite{Seacord1999}, the representation problem \cite{Pole1994}, the usability problem\cite{Garcia2006}, and the retrieval problem \cite{Prieto-Diaz1987}.

The rise of open-source movement, the improvements in the Internet connectivity, the advances in database, and the emergence of code-search engines have clearly solved the first problem. Techniques such as ranking approaches like SOCORA \cite{Kessel2016}, the ranking based on use relations presented by \citeauthor{Inoue2005}, and the idea of parsing source code in order to extract objects introduced by Koders.com \footnote{Discontinued.} have addressed the representation problem. Furthermore the test-driven search technique \cite{Hummel2004,Hummel2013} promises to solve the representation, usability and retrieval problems, by finding functionally sufficient components based on tests.

Additionally there exists a software development practice called Continuous Integration (CI), which has continuesly been gaining popularity over recent years \cite{Perforce2015}. In this practice members of a team integrate their work frequently, usually each person integrates at least daily, thus leading to multiple integrations per day. Each integration is verified by an automates build (including test) to detect integration errors as quickly as possible. Many teams has found that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software quicker \cite{Fowler2006}.

Here is when the following questions came up: \emph{How can Software Reuse and Continuous Integration be best married?}.

Software projects which adopt continuous integration normally adopt the agile development technique called test-driven development (TDD), where a test case is created before the actual code which needs to be implemented. Thus, in addition to the frequent commits made by the developers, we found a great chance to improve the chances of reusing software components. Every time a new code is pushed to the version control server (VCS), the CI server is triggered. At this moment it is possible to analyze the source code and extract test classes, along with the interface signature, to sent them to a code-search engine. This engine will retrieve the result candidates that meet the functional requirements of the test classes, and then the result will be sent to the developers. Consequently the team will realize that what they are working on might be already available in the internet so they would not need to re-implement the same component from scratch.

In the reminder of this document we explain with further details how this approach works. First, in Chapter \ref{foundations} we provide the foundations and concepts needed to understand the approach proposed. There we will start explaining about what software reuse practice means. Then we move to the agile practice test-driven development. After that we explain about continuous integration process. To conclude this chapter, we talk about microservices. In the next Chapter we describe the usage scenario in order to motivate and strengthen the approach which is presented in Chapter \ref{chap:simile}. There we detail our approach, its design, how we implemented it, the results of applying it and the technologies we used. To close this thesis, in Chapter \ref{discussion}, \ref{future-work}, and \ref{conclusion} we discuss about potential pros/cons of this work, future work on the idea, and conclusion respectively.




