\chapter{Introduction}
\label{chap:introduction}
Building software using already existent components is not new. During the 1960s Douglas MacIlroy came up with this vision of a software system composed of components. Where you basically put different pieces (components), that already exist, together in order to form the system being built. During the next 50 years of MacIlroy's vision, the IT industry has tried to improve the speed and reduce the cost of development by reusing software, however this vision is still far for being a reality.

This process has attracted the attention of the industry due to its alleged benefits. Reduction of redundancies, costs reduction, quality improvements, and fostering innovation are some of the benefits that come with reusing software. However this is not an easy task.

The adoption of suitable reuse strategies is pretty challenging as it takes place in a multifaceted environments which incorporate aspects spanning from technical to organizational at different level of abstractions \cite{Bauer2016}. In general the challenges can be divided in organizational and technical \cite{Hummel2013,Bauer2016}. In the former, problems such as organizational structure, inertia, knowledge, management, among others might affect the success of the implementation of software reuse. For the latter, four core problems have been identified in the literature to implement a sustainable reuse repository: the repository problem \cite{Seacord1999}, the representation problem \cite{Pole1994}, the usability problem\cite{Garcia2006}, and the retrieval problem \cite{Prieto-Diaz1987}.

The rise of open-source movement, the improvements in the Internet connectivity, the advances in database, and the emergence of code-search engines have clearly solved the first problem. Techniques such as ranking approaches like SOCORA \cite{Kessel2016} or the ranking based on use relations presented by \citeauthor{Inoue2005}, and the idea of parsing source code in order to extract objects introduced by Koders.com \footnote{Discontinued.} have addressed the representation problem. Furthermore test-driven search technique \cite{Hummel2004,Hummel2013} promises to solve the representation, usability and retrieval problems.

On the other hand we have Continuous Integration (CI), which is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily, thus leading to multiple integrations per day. Each integration is verified by an automates build (including test) to detect integration errors as quickly as possible. Many teams has found that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software quicker \cite{Fowler2006}.

Here is when the following questions came up: \emph{How can Software Reuse and Continuous Integration be best married?}.

Software projects that adopt continuous integration normally adopt the agile development technique called test-driven development (TDD), where a test case is created before the actual code that need to be implemented. Thus, in addition with the frequent commits made by the developers, we found a great chance to improve the chances of reusing software components. Every time new code is pushed to the version control server (VCS), the CI server is triggered. At this moment we are able to analyze the source code and extract test class, along with the interface signature, to sent them to a code-search engine. This engine will retrieve the result candidates that meet the functional requirements of the test classes, and then they will be sent to the developers. Consequently the team will realize that what they are working on might be already available in the internet so they would not need to re-implement the same again.

In the following chapters we explain with further details how this approach works. First, in Chapter \ref{foundations} we provide a background for the approach. Then in Chapter \ref{usage-scenario} we explained a usage scenario in order to motivate and strengthen the approach which is presented in Chapter \ref{chap:simile}. There we detail our approach, how we implement it, and the benefits of this proposal. In Chapter \ref{discussion} and \ref{future-work} we discuss about potential pros/cons of this work and future work. We finalize this document presenting the conclusions.




