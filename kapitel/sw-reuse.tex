\chapter{Software Reuse}
\label{chap:sw-reuse}

Software reuse is often associated to \cite{McIlroy1968}, where the author envisioned a software system composed of already existent components. Thus by reusing software components projects can reduce time-to-market, lower development costs, and increase software quality \cite{Frakes2005}. 

\textbf{Internal vs external software reuse}\\
So far researches on software reuse have focused mainly on how organizations reuse in-house developed assets across different projects, also called systematic software reuse \cite{Stefi2016}. However, nowadays there are works that focus on 

\cite{Frakes2005} \\

\textbf{Introduction}
\begin{itemize}
\item Software reuse is the use of existing software or software knowledge to construct new software.
\item Reusable asset can be either reusable software or software knowledge
\item Reusability: It is a property of a software asset that indicates its probability of reuse 
\item Software reuse's purpose is to improve software quality and productivity
\item Software reuse is of interest because people want to build systems that are bigger and more complex, more reliable, less expensive and that are delivered on time.
\end{itemize}

\textbf{History}
\begin{itemize}
\item Software reuse... is often traced to \cite{McIlroy1968} paper which proposed basing the software industry on reusable components. Other significant reuse researcher is Parnas, who proposed program families, and Neighbor's introduction of the concept of domain and domain analysis.
\item Reuse was clearly a key design goal of the UNIX programming environment
\item C++ language was also designed to encourage reuse as described in \cite{Stroustrup}
\end{itemize}

\cite{Stefi2016} \\
\textbf{Theoretical background}
\begin{itemize}
\item The idea of software reuse was introduced by \cite{McIlroy1968} who envisioned software components, similar to other mature engineering disciplines. The idea of software reuse promises to reduce time-to-market, to lower software development costs, and to increase software quality \cite{Frakes2005}.
\end{itemize}

\cite{Kessel2016} \\
\textbf{Introduction}
\begin{itemize}
\item The reuse of existing software components from company-wide or open-source repositories is often an appealing alternative to the costly development of new components from scratch.
\item A developer needs to trade-off the instant availability of such potentially reusable candidate against the effort needed to find them and adapt them to achieve the level of quality required in his/her context and usage scenario.
\item Most research in the field of reuse has traditionally focused on offering tool-aided guidance and advice for adapting and integrating code, once selected, into a new application.
\item Code recommendation tools and specifically code search engines provide the basic platform for supporting the "findings" part of the reuse process. 
\end{itemize}

\cite{Ezran2002}\\
\begin{itemize}
\item Software reuse is the systematic practice of developing software from a stock of building blocks, so that similarities in requirements and/or architecture between applications can be exploited to achieve substantial benefits in productivity, quality and business performance.
\end{itemize}

Organizations face several problems in software development including increased costs, delayed schedules, unsatisfied requirements, and software professional shortage. This situation is often called the software development crisis \cite{Kim1992}.

The concept of software reuse has been around for more that 40 years in the literature. Inspired by other engineering disciplines, Douglas McIlroy in \citep{McIlroy1968} introduced the vision of the (re-)use of pre-fabricated software parts in order to promote the booming component marketplaces. Since then it has been considered as a mean to help solve the software development crisis \cite{Kim1992}.

Although the definition of software reuse seems trivial, it possible to find several definitions in the literature. However, most of them are similar to the definition found in \cite{Krueger1992}:

"Software reuse is the process of creating software systems from existing software rather than building software systems from scratch"

Since we already have a formal definition of software reuse, the next question would be: What can be reused?. To this regard, the work of \cite{Frakes1996} defined a list of potentially reusable software artifacts:

\begin{table}[]
\centering
\label{my-label}
	\begin{tabular}{|l|l|}
		\hline
		1. architecture						 & 6. estimates (templates) \\ \hline
		2. source code  						 & 7. human interfaces      \\ \hline
		3. data                               & 8. plans                 \\ \hline
		4. designs                            & 9. requirements          \\ \hline
		5. documentation                      & 10. test cases           \\ \hline
	\end{tabular}
	\caption{Potentially reusable aspects of software projects according to \cite{Frakes1996}.}
\end{table}

However, reuse traditionally meant the reuse of code fragments and components \cite{Mili2002}. 

several works have focused on analyzes, methods, tools, and empirical investigations with the idea of supporting practitioners in executing reuse tasks. 

\cite{Kim1992} defined that the field of software reuse needs tools for modeling the productivity gains from reuse, needs to understand better how to build reusability, needs to understand the role of reusability in the generation, composition, object-oriented, and CASE approaches to software development, needs to develop improved methods for classifying, organizing, and retrieving software resources. Finally, it needs to know how to build a supportive organizational environment and to solve the psychological problems of motivation and bounded rationality.

In fact, component-based software reuse is considered one of the attributes that would bring software engineering closer to the standard of a fully-fledged engineering discipline \cite{Mili1999}. However, component-based software reuse and the required component markets still have not made the assumed breakthrough, which will be detailed later in this work.

 

