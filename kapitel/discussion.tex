\chapter{Discussion}
\label{discussion}
The first question that arouse during this work is: \emph{Is this approach beneficial?}. As a first attempt to improve software reuse by using continuous integration, it is difficult to answer the question. In fact, it is more likely that at this version it might not be very helpful due to its immaturity. However, it is very promising in the future. In this chapter we will discuss about the possible pros and cons of this work.

This approach reduces the effort of searching suitable components by analyzing the code in background. Simile was conceived as unobtrusive tool as possible, that is why we found a great opportunity in the continuous integration process and the agile technique TDD. When a project is developed using TDD, the tests are written before the code that need to be implemented. Also according to the CI workflow, developers should commit changes as often as possible which trigger the CI server to validate the changes by testing the code. At this moment we visualized a great chance to look for similar components using textual and test-driven search approaches. Whenever the CI server is triggered we have the chance to analyze the code, extract interface signatures, and test classes which are sent to the code-search engine to retrieve similar components to the components that are being implemented. Thus developers might be able to reduce risk and development cost by reusing components which implement the functionality they are working on. Moreover it reduces the effort needed for searching components by running in background without disturbing the work of the developers.

Our prototype is able to provide high precision result that fully meet functional requirements. As test-driven search technique is able to provide the best results from the semantic point of view \cite{Reiss2009,Hummel2008,Hummel2013}, we can assure that the precision of the components returned is very high (depending on the quality of the tests). We achieve this by relying on Merobase as code-search engine.

Although Simile can provide high precision on the components retrieved, if these are not ranked accordingly the effort invested on reusing components would increase. We solve this problem by relying on SOCORA which is able to rank components using combination of non-functional properties such as performance or maintenance \cite{Kessel2016}.

The future of Simile appear to be attractive due to the massive adoption of CI/CD. Continuous Integration/Delivery adoption rates is showing an unexpected increment. According to the research made by Perforce Software \cite{Perforce2015}, 65\% of companies have adopted CI/CD in some or all projects. Moreover, 40\% of open-source projects in Github have also adopted Continuous Integration \cite{Hilton2016}. This is a great opportunity for this tool to be used vastly by companies and open-source projects, helping them to reduce development costs and time.

%%%%% CONS

This approach also has some possible cons. If a team does not use TDD or any test, Simile would only be able to extract interface signatures from the code. Therefore the result retrieved would not be as precise as it would be using tests. This is due to the fact that the search would be based on keyword and text-matching techniques which do not necessarily meet functional requirements.

Another cons is the high time it might takes to deliver a result. Test-driven search component is heavy-weight task because it requires to run tests to for each possible candidate. Although it has been improved by parallelization of test execution and optimizing the underlying code-search engine, it still takes a reasonable time for returning a result. This time can be even bigger depending on the complexity of the tests used for searching components.

One more cons is the bad quality of the documentation of the candidate components. Although the components retrieved meet the functional requirements of the user, if they are poorly documented or they are hard to understand the effort invested on reusing them will be high. Therefore it would be helpful to consider the quality of the code and documentation of the components retrieved.


 