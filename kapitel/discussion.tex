\chapter{Discussion}
\label{discussion}
The first question which arose during this work is: \emph{Is the approach proposed beneficial?}. As a first attempt to improve software reuse by using continuous integration, it is difficult to answer the question easily. In fact, it is more likely that at this point it might not be all too helpful due to its immaturity. However, it looks very promising in the future. In this chapter we discuss about the possible pros and cons of this approach.

Simile reduces the effort of searching suitable components by analyzing the code in the background. It was conceived as an unobtrusive tool which is why we found a great opportunity in the continuous integration process and in the agile technique TDD. When a project is developed using TDD, the tests are written before the code which needs to be implemented. In addition according to the CI workflow, developers should commit changes as often as possible which trigger the CI server to validate said changes by testing the code. At this moment we visualized a great chance to look for similar components using interface-driven search, keyword search, and test-driven search approaches. Whenever the CI server is triggered we have the chance to analyze the code, to extract interface signatures, and test classes which are sent to the code-search engine to retrieve similar components to the components that are being implemented. Thus developers might be able to reduce risk and development costs by reusing components which implement the functionality they are working on. Moreover it reduces the efforts needed to search components by running in the background without disturbing the work of the developers.

Our prototype is able to provide high precision result that fully meet functional requirements. As the test-driven search technique is able to provide the best results from the semantic point of view \cite{Reiss2009,Hummel2008,Hummel2013}, we can assure that the precision of the returned components is very high (depending on the quality of the tests). We achieve this by relying on Merobase as code-search engine.

Although Simile can provide high precision on the retrieved components, if these are not ranked accordingly the effort invested in reusing components will increase. We solved this issue by relying on SOCORA which is able to rank components using combination of non-functional properties such as performance or maintenance \cite{Kessel2016}.

The future of Simile appears to be attractive because the massive adoption of CI/CD. Continuous Integration/Delivery adoption rates are showing an unexpected increment. According to the research made by Perforce Software \cite{Perforce2015}, 65\% of companies have adopted CI/CD in some or all projects. Moreover, 40\% of open-source projects in Github have also adopted Continuous Integration \cite{Hilton2016}. This is a great opportunity for this tool to be used vastly by companies and open-source projects, helping reduce development costs and time.

%%%%% CONS

This approach also has some possible cons. If a team does not use TDD or any test, Simile would merely be able to extract interface signatures from the code. Therefore the results retrieved would not be as precise as it would be using test cases. This is due to the fact that the search would be based on interface-signature, keyword, and text-matching techniques which return components that do not necessarily meet functional requirements.

Another issue is the high time it might take to deliver a result. Test-driven search is a heavy-weight task because it requires running tests for each possible candidate to validate if they meet the functional requirements. Although it has been improved by parallelization of test execution and optimizing the underlying code-search engine, it still takes a considerable time for returning a result. This time span can be even bigger depending on the complexity of the test cases used for searching components.

One more problem is the bad quality of the documentation of the candidate components. Although the retrieved components meet the functional requirements of the user, if they are poorly documented or hard to understand the effort invested in reusing them will be rather high. Therefore it would be helpful to consider the quality of the code and documentation of the retrieved components.


 