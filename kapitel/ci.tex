\section{Continuous Integration}
\label{chap:ci}

In this chapter we will explain what Continuous Integration (CI) means, we will describe the process steps, its benefits and challenges. Finally we will explain how CI can be leveraged in order to improve Software Reuse.

\subsection{What is Continuous Integration?}
\label{sec:ci-def}

The term can be found in the context of micro-processes development in the work of \cite{Booch2007}. Then it was adopted by Kent Beck in his definition of Extreme Programming \citep{Beck1999}. However, it was Martin Fowler who was credited with establishing the current definitions of the practices. Fowler defines CI as following:

CI is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily, thus leading to multiple integrations per day. Each integration is verified by an automates build (including test) to detect integration errors as quickly as possible. Many teams has found that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapid\citep{Fowler2006}.

Continuous Integration emerges as a solution for the painful moment of software integration. Although the process of integrating software is not a problem for a one-person project, when it increases in complexity it becomes more problematic. For example, in the old days, a software was divided in modules and each of them were developed independently, once they done, those modules were put together in one step at the end of the project. Doing that led to all sorts of software quality problems, which are costly and often lead to project delays \citep{Duvall2007}.

This step of module integration was a tense moment as errors and failures appeared and they were difficult to find and fix at that stage of the development. In this manner, instead of waiting till the end of modules development to integrate, CI proposes to integrate frequently, usually one person should integrate at least once a day.

Therefore we can break up the CI workflow in the following steps \citep{Fowler2006}:

\textbf{CI Workflow:}

\begin{itemize}
\item Developers check out code into their private workspaces
\item When done, commit the changes to the repository
\item The CI server monitors the repository and checks out changes when they occur.
\item The CI server builds the system and runs unit and integration tests.
\item The CI server releases deployable artifacts for testing.
\item The CI server assigns a build label to the version of the code it just built.
\item The CI server informs the team of the outcome of the build.
\item In case the build or test failed, the team fixes the issue at the earliest opportunity.
\item Continue to continually integrate and test throughout the project.
\end{itemize}

This uncomplicated workflow helps the development team to focus on the current code change till it is verified and validated. Moreover, it provides continuous feedback on the quality of the code.

\subsubsection{CI Tools}

Although the CI is tool agnostic, the selection of them depends on the project, framework in use, skill-set of the stakeholders and other factors. There are however two must-have tools of any CI system: (1) the version control system (VCS) and (2) the CI server.

The most popular VCS are Git, Mercurial and SVN. On top of them, we can find Version Control Platforms (VCP) such as Github, Gitlab or Bitbucket. In terms of CI servers, we can find Jenkins, Hudson, GoCD as open source projects; TravisCI, CircleCI, CodeShip and Team City as commercial tools.

Therefore choosing the appropriate tools is about finding the balance between price, setup, configuration efforts, ease-of-use, integration capabilities between the selected tools, framework suitability and maintainability in respect to current code base.

\paragraph{Git}
Within the several different VCSs available, Git is one of the most popular\footnote{https://rhodecode.com/insights/version-control-systems-2016 (accessed: 14.01.2017)}. Git emerges in 2005 as an alternative to BitKeeper\footnote{https://www.bitkeeper.com/ (accessed: 13.01.2017)} after the break of the relationship between the commercial company behind BitKeeper and  the community that developed the Linux kernel \citep{Chacon2009}.

The main difference between Git and the other VCSs is the way it thinks about its data. Other VCSs such as Subversion, CVS, Perforce, and so on, think of the information they keep as a set of files and the changes made to each file over time. On the other hand, Git thinks its data like a set of snapshots of a miniature file system. Therefore, every time a user commits, or save the state of the project, Git basically takes a picture of what all the files look like at that moment and store a reference to that snapshot. In addition, Git has three main states where the files can reside in: committed, modified, and staged. Committed means that the data is stored in the local database. Modified means that the file was modified but it has not been committed yet. And staged means that the modified file has been marked to go into the next commit \citep{Chacon2009}. The figure \ref{fig:git-sates} depicts these three states.

\begin{figure}[ht]
	\centering
    \includegraphics[width=\textwidth]{grafiken/git-states}
    \caption{The three main states of Git \citep{Chacon2009}}
    \label{fig:git-sates}
\end{figure}

The git directory is the core of Git as it is where the metadata and object database for a project is stored. The working directory is a single checkout of one version of the project. Finally, the staging area is a file which is generally stored in the Git directory. This file contains information about what will go into the next commit.

\paragraph{Github}

Github\footnote{https://github.com/ (accessed: 13.01.2017)} is a web-based Git repository hosting service, which offers all the functionality of Git and its own features. It provides several collaboration tools such as wikis, bug tracking, feature requests, and task management as well as access control. Its development started in 2007 as a side project of P. J. Hyett and Chris Wanstrath \citep{Weis2014} and it was officially lunch on the 10th of April in 2008. Since then, Github has gain popularity through the community reaching more than 50 million projects hosted nowadays.

\paragraph{Jenkins}
Jenkins is an open source automation server developed in Java. It was originally founded in 2006 as \textit{Hudson}, however a disputed with Oracle the community behind Hudson decided to change the project name to Jenkins\footnote{http://archive.is/fl45 (accessed: 13.01.2017)}.

Jenkins enables developers to reliable build, test, and deploy their software. Its extensible and plugin-based architecture has permitted to create a tons of plugins to adapt the CI server to a multitude of build, test, and deployment automation workloads. In 2015, Jenkins surpassed 100.000 known installation making it the most widely deployed automation server\footnote{https://jenkins.io/press/ (accessed: 13.01.2017)}. 

\subsection{Benefits in adopting CI/CD}
\label{ci-benefits}

Several are the benefits that come with the adoption of Continuous Integration in a software project. In this section we will describe five areas that are improved after CI implementation \citep{Rejstrom2016}. It is important to point out that these benefits come along with other practices such as agile transformation \citep{Laanti2011} and lean software development \citep{Poppendieck2003}.

\begin{itemize}
\item Shorter time-to-market: Many benefits come with the adoption of frequent releases. With fast and frequent releases is possible to get feedback quickly from customer and market, thus the organization gets better understanding of their needs expectations \citep{Neely2013}. With that is possible to focus on the most relevant features. Another benefit of delivering frequently is waste reduction as features can be deployed as soon as they are done \citep{Leppanen2015}. Furthermore, with frequent releases is possible to experiment with new features easily and with low impact \citep{Neely2013}.
\item Rapid feedback: With frequent releases is possible to show progress to customers and by that get feedback quickly. With that the development team can focus on important features instead of waste time in features that are not relevant for the customers or the market.
\item Improved software quality: Researches have reported a decreased in the number of open bugs and production incidents after adopting CI practices \citep{Mantyla2015} and the link between software quality improvement and the heavy reliance on automated test combined with smaller more manageable releases \citep{Leppanen2015}.
\item Improved release reliability: In the work of \cite{Neely2013} was proved that a working deployment pipeline along with intensive automated testing and fast rollback mechanism possitively affects release reliability and quality. With small and frequent releases fewer things can go wrong in a release according to \cite{Fowler2013}. In fact, reduction in the stress of developers and other stakeholder have been found by adopting CI \citep{Neely2013} \citep{Chen2015}.
\item Improved developer productivity: By automating deployment process, environment configuration and other non-value adding tasks, significant time saving for developers have been observed \citep{Rodriguez2016}. Also, in the work of \cite{Humble2010} was observed that although the setup cost of a deployment pipeline can be high, after it is setup developers can focus on value adding software development works.
\end{itemize}

\subsection{Challenges in adopting CI/CD}
\label{ci-challenges}

Adopting CI can be very beneficial for a software project as described above, however we can face some challenges that can jeopardize the successful implementation of it. According to the literature, there are seven common challenges in the implementation of a CI:

\begin{itemize}
\item Change resistance: Transforming the development of a project towards continuous integration practices requires investment and involvement from the entire organization \citep{Rodriguez2016}. Therefore any transformation in how an organization works, will receive a resistance on both a personal level and decision level within the organization.
\item External constraint: As a software project is part of a context, external constraint may appear. Normally customer preferences and domain imposed restrictions are sources of constraints. For example in highly restricted domains, legal regulations may require extensive testing before new version can be allowed to enter production \citep{Rodriguez2016}.
\item QA effort: The automated tests suit needs to be exhaustive enough in order to ensure the quality of what is being built. Thus it can lead to increase QA efforts due to difficulties in managing the test automation infrastructure \citep{Rodriguez2016}.
\item Legacy code: Normally legacy software has not been design for being automatically tested and may cause integration failures which may inhibit the continuous deployment process. The ownership of legacy code might belong to another company or team which shift the testing responsibility and this might delay the deployment process.
\item Complex software: If the complex if the software project is high, then setting up the CI workflow is more challenging \citep{Leppanen2015}.
\item Environment management: Keeping all the environments used in development, testing and production sync and similar can be challenging. This is due to the fact that differences in the environment configuration can lead to undetected issues appear in production. Therefore is essential to have a good configuration management that provisions environments automatically \citep{Leppanen2015}.
\item Manual testing: Although automated tests are very beneficial, some aspects of software need to be manually tested such as security issues, performance and UX/UI. Therefore 	heavy manual testing can impact the overall speed and smoothness of the process \citep{Leppanen2015}.
\end{itemize}

\subsection{Successful CI practices}
\label{ci-successful-pract}

In order to reduce the risks in adopting CI practices, eight principles, based on several literature reviews, were defined in \citep{Rejstrom2016} which should guide the CI implementation within organizations. These principles are generic solutions which can be adapted in most cases.

\begin{itemize}
\item Automate the build: The task that triggers the whole pipeline is the commit. After each commit, the next step should be build the binaries. The executable that result of the build, should go through the pipeline until it gets validated, verified and deployment ready.
\item Make your build self-testing: 
\item Every commit should build on an integration machine
\item Keep the build fast
\item Keep the build green
\item Test in a clone of the production environment
\item Everyone can see what is happening
\item Automate deployment
\end{itemize}

These 8 principles should guide the CI/CD implementation within organizations. The principles have been stablished as best practices through the validation of these concepts through several literature reviews [\cite{Rodriguez2016}; \cite{Mantyla2015}; \cite{Stahl2014}]. They can be viewed almost as a design pattern for adopting CI/CD, offering a generic solution adaptable to most cases.