\section{Test-Driven Development}
\label{sec:tdd}
In this section we will explain Test-driven development (TDD). TDD combines test-first development where you write a test before writing just enough production code to fulfill that test, and refactoring it. The primary goal of TDD is to think requirements or design through before writing functional code (implying that TDD is both an important agile requirements and agile design technique)\cite{Martin2002}. In the reminder of this section we explain the definition of TDD further, and finally compare it against normal testing.
\subsection{Definition}
The steps of test-first development (TFD) are displayed in the activity diagram of Figure \ref{fig:tfd}. The first step is to quickly add a test. Then it is executed, often the complete test suite although one may decide to run only a subset for the sake of speed, to ensure that the new test fails. After that the developer updates the functional code to make it pass the tests. The fourth step is to run your tests again. If they fail he/she needs to update the functional code and retest. Once the tests pass, the next step will be to start over again. One may first need to refactor the code if needed, in that case we are turning TFD is turned into TDD.

TDD completely inverts traditional development. When a developer first goes to implement a new feature, the first question that he/she asks is whether the existing design is the best design possible that enables him/her to implement that functionality. If so, he/she proceeds via a TFD approach. If not, he/she refactors it locally to change the portion of the design affected by the new feature, enabling him/her to add that feature as easy as possible. As a result he/she will always be improving the quality of the design, thereby making it easier to work with in the future. Figure \ref{fig:tdd} describes the TDD lifecycle just described.

Instead of writing functional code first and then writing testing code, if it is written at all, a developer instead writes test code before the functional code. Moreover, he/she does so in very small steps (i.e. one test and a small bit of proportional functional code at a time). A programmer taking a TDD approach refuses to write a new function until there is a test first that fails because that function is not present yet. In fact, they refuse to add even a single line of code until a test exists for it. Once the test is in place then they do the work required to ensure that the test suite now passes (i.e. new code may break several existing tests as well as the new one). Although it sounds simple, one needs great discipline as it easy to forget it and to write functional code without first writing a new test.

\begin{figure}[H]
	\centering
    \includegraphics[width=0.5\textwidth]{grafiken/tfd}
    \caption{Test-First Development}
    \label{fig:tfd}
\end{figure}

There are two levels of TDD\cite{Ambler2013}:

\paragraph{Acceptance TDD (ATDD)} is when one writes a single acceptance test, and then just enough production functionality code to fulfill that test. The goal of ATDD is to specify detailed, executable requirements for your solution on a just in time (JIT) basis\cite{Ambler2013}. ATDD is also known as Behavior Driven Development (BDD).

\begin{figure}[H]
	\centering
    \includegraphics[width=\textwidth]{grafiken/tdd}
    \caption{Test-driven Development Lifecycle\cite{Ambler2013}}
    \label{fig:tdd}
\end{figure}

An acceptance test represents the user's point of view or the external view of the system. It inspects the externally visible effects such as specifying the correct output of a system given a particular input. For instance, an acceptance test can display how the state of an \emph{Order} changes from \emph{paid} to \emph{shipped}. Moreover, it can specify the interaction with interfaces of other systems. Furthermore, acceptance tests can suggest that operations normally hidden from direct testing (such as business rules) should be exposed for testing\cite{KennethPugh2011}.

These tests are written by the customer, tester, and developer (also called \emph{three amigos}\cite{Dinwiddie2009}). The customer should create at least one test working together with the developer and the tester. The latter then can create more tests and have them reviewed by the customer. The developer connects the tests to the system by writing short bits of code. The idea behind it is that anyone can run the tests, manually or automatically. These tests are written in business domain terms which form a common language which is shared between the \emph{three amigos}\cite{KennethPugh2011}.

\paragraph{Developer TDD} one writes a single developer test, sometimes called unit test, and then just enough production code to fulfill that test. The goal of developer TDD is to specify a detailed, executable design for your solution on a JIT basis. Developer TDD is often simply called TDD\cite{Ambler2013}.

\begin{figure}[H]
	\centering
    \includegraphics[width=0.7\textwidth]{grafiken/atdd-tdd}
    \caption{Aceptance TDD and Developer TDD\cite{Ambler2013}}
    \label{fig:atdd-tdd}
\end{figure}  

Figure \ref{fig:atdd-tdd} depicts how ATDD and developer TDD fit together. Preferably, it will begin with adding a single acceptance test written by the customer, developer and tester. Then run the test and if it passes, add another acceptance test, otherwise make a small change in the acceptance test and add a developer test. After adding the developer test, run it. If it passes, add another developer test, otherwise add enough code to make the test to pass. The developer test cycle ends when the functionality defined by the acceptance test is fulfilled. Then run the acceptance tests to check if all of them passes. The ATDD cycle will end when the development stops otherwise it continues.

\subsection{Why TDD?}
TDD is a practice that has been promoted because it is far more productive than coding in larger steps\citep{Ambler2013}. Imagine a developer adding a functional code, compiling, and testing it. It is very likely that the test will be broken by defects that exist in the new code. Therefore, it will be easier to find and fix those defects if he/she has only written two lines of code instead of hundreds. Consequently, the most important benefit acquired by applying TDD is that it enables the programmer to take small steps when developing a software.

TDD facilitates easy maintenance and helps alleviate scope creep. In TDD, code is never written without first writing a test. This results in a great test coverage. Further, the refactoring process ensures written code to be as economical as possible, streamlining the code. If there is not a use-case for a piece of functionality, the test is never written, thus the code does not grow.

Test-driven development is a way of managing fear of making changes in code during software development\cite{Beck2003}. TDD gives organizations the ability to painlessly update their software to address new business requirements or other unforeseen variables. Since testing in TDD is integrated into the development process at the most granular level, it is guaranteed that every standalone piece of logic can be tested, and thus changed confidently. As described above, by programming in small steps, any error can be overcome quickly. Furthermore, at the end of the application development thousands of test cases exist. Therefore, when a software has a considerable complexity, normally making a change in the code is a critical moment for a developer because he/she is scared of breaking something in another part of the application. However, if the project applies TDD from the beginning, when a change is made to the application, all that must be done is to run the existing test cases in order to see if the change has adversely impacted any other piece of the application.

As a conclusion, TDD is a great tool for young companies which seek rapid growth, for older organizations which need to update their legacy systems, and organizations which want to diversify service options or revenue channels.
