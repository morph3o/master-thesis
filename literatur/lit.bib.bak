@article{Frakes2005,
author = {Frakes, W.B. and {Kyo Kang}, Kyo},
doi = {10.1109/TSE.2005.85},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Frakes, Kyo Kang - 2005 - Software reuse research status and future.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Computer science,Finance,Index Terms- Software reuse,Productivity,Reliability engineering,Software architecture,Software engineering,Software libraries,Software quality,Software reusability,Software systems,architectures,domain engineering,finance.,generators,metrics,research,research and development,software architecture,software engineering,software metrics,software reusability,software reuse,software reuse research},
mendeley-tags = {software reuse},
month = {jul},
number = {7},
pages = {529--536},
publisher = {IEEE},
title = {{Software reuse research: status and future}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1492369},
volume = {31},
year = {2005}
}

@article{McIlroy1968,
abstract = {QUOTE: "The most important characteristic of a software components industry is that it will offer families of routines for any given job. No user of a particular member of a family should pay a penalty, in unwanted generality, for the fact that he is employing a standard model routine. In other words, the purchaser of a component from a family will choose one tailored to his exact needs. He will consult a catalogue offering routines in varying degrees of precision, robustness, time-space performance, and generality. He will be confident that each routine in the family is of high quality - reliable and efficient. He will expect the routine to be intelligible, doubtless expressed in a higher level language appropriate to the purpose of the component, though not necessarily instantly compilable in any processor he has for his machine. He will expect families of routines to be constructed on rational principles so that families fit together as building blocks. In short, he should be able safely to regard components as black boxes."},
author = {McIlroy, M.D.},
journal = {Software Engineering: Report on Conference Sponsored by NATO},
keywords = {- industrialization model for programming,component factory,software components as black boxes,software reuse,taking signals from mass production methods.  mana},
mendeley-tags = {software reuse},
pages = {138--155},
title = {{Mass Produced Software Components}},
year = {1968}
}

@inproceedings{Stroustrup,
author = {Stroustrup, B.},
booktitle = {Proceedings of Fourth IEEE International Conference on Software Reuse},
doi = {10.1109/ICSR.1996.496109},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Stroustrup - Unknown - Language-technical aspects of reuse.pdf:pdf},
isbn = {0-8186-7301-X},
pages = {11--19},
publisher = {IEEE Comput. Soc. Press},
title = {{Language-technical aspects of reuse}},
url = {http://ieeexplore.ieee.org/document/496109/},
year = {1996}
}

@article{Stefi2016,
author = {Stefi, Anisa and Lang, Karl and Hess, Thomas},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Stefi, Lang, Hess - 2016 - A Contingency Perspective on External Component Reuse and Software Project Success.pdf:pdf},
journal = {AMCIS 2016 Proceedings},
keywords = {software reuse},
mendeley-tags = {software reuse},
title = {{A Contingency Perspective on External Component Reuse and Software Project Success}},
url = {http://aisel.aisnet.org/amcis2016/ITProj/Presentations/16},
year = {2016}
}

@article{Kessel2016,
author = {Kessel, Marcus and Atkinson, Colin},
doi = {10.1007/s10796-016-9685-3},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Kessel, Atkinson - 2016 - Ranking software components for reuse based on non-functional properties.pdf:pdf},
issn = {1387-3326},
journal = {Information Systems Frontiers},
keywords = {software reuse},
mendeley-tags = {software reuse},
month = {jul},
pages = {1--29},
publisher = {Springer US},
title = {{Ranking software components for reuse based on non-functional properties}},
url = {http://link.springer.com/10.1007/s10796-016-9685-3},
year = {2016}
}

@book{Ezran2002,
abstract = {Right context, software reuse promises high value to businesses that$\backslash$ndevelop software, opening the door to radical improvements in their$\backslash$nsoftware capability (productivity, cost, time to market). Attempts$\backslash$nto adopt reuse without a sound understanding of the range of issues$\backslash$ninvolved, however, can lead to expensive failure. This book is for$\backslash$nthose who are wondering whether they should adopt reuse and how,$\backslash$nand also to those who have already started to adopt it but are wondering$\backslash$nwhere they may be going wrong and how they could do better. It consistently$\backslash$nemphasizes the practical issues that influence success or failure$\backslash$nin reuse; and it offers a concise and balanced coverage of the essentials$\backslash$nof the subject, rather than going into undue depth or detail on some$\backslash$ntopics at the expense of others. It occupies the central ground between$\backslash$nbeing on the one hand an academic textbook and on the other hand$\backslash$na cookbook with ready-made recipes for exactly ``how to do it''. The$\backslash$nauthors have drawn on their extensive experience of reuse and of$\backslash$nsoftware process improvement to provide a readable and balanced coverage$\backslash$nof the subject. This book is suitable for business executives, software$\backslash$nmanagers and software developers, regardless of whatever kind of$\backslash$nsoftware or applications are developed by their organisations, and$\backslash$nwhatever the size of those organisations. A special feature of the$\backslash$nbook is the frequent use of experience notes, drawn from the real-life$\backslash$nexperience of organisations that have embarked on the reuse adventure.},
author = {Ezran, Michel and Morisio, Maurizio and Tully, C J},
booktitle = {Practitioner series,},
doi = {citeulike-article-id:3944385},
isbn = {1852335025 (pbk.) :},
keywords = {Computer software Reusability.,software reuse},
mendeley-tags = {software reuse},
pages = {xxi, 222},
title = {{Practical software reuse}},
year = {2002}
}

@article{Mili1999,
author = {Mili, A. and Yacoub, S. and Addy, E. and Mili, H.},
doi = {10.1109/52.795098},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Mili et al. - 1999 - Toward an engineering discipline of software reuse.pdf:pdf},
issn = {07407459},
journal = {IEEE Software},
number = {5},
pages = {22--31},
title = {{Toward an engineering discipline of software reuse}},
url = {http://ieeexplore.ieee.org/document/795098/},
volume = {16},
year = {1999}
}

@inproceedings{Kim1992,
author = {Kim, Y. and Stohr, E.A.},
booktitle = {Proceedings of the Twenty-Fifth Hawaii International Conference on System Sciences},
doi = {10.1109/HICSS.1992.183360},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Kim, Stohr - 1992 - Software reuse issues and research directions.pdf:pdf},
isbn = {0-8186-2420-5},
pages = {612--623 vol.4},
publisher = {IEEE},
title = {{Software reuse: issues and research directions}},
url = {http://ieeexplore.ieee.org/document/183360/},
year = {1992}
}

@article{Krueger1992,
author = {Krueger, Charles W. and W., Charles},
doi = {10.1145/130844.130856},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Krueger, W. - 1992 - Software reuse(2).pdf:pdf;:Users/morph3o/Mannheim/Thesis/Papers/Krueger, W. - 1992 - Software reuse.pdf:pdf},
issn = {03600300},
journal = {ACM Computing Surveys},
keywords = {abstraction,cognitive distance,software reuse},
month = {jun},
number = {2},
pages = {131--183},
publisher = {ACM},
title = {{Software reuse}},
url = {http://portal.acm.org/citation.cfm?doid=130844.130856},
volume = {24},
year = {1992}
}

@article{Frakes1996,
author = {Frakes, William and Terry, Carol},
doi = {10.1145/234528.234531},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Frakes, Terry - 1996 - Software reuse metrics and models(2).pdf:pdf},
issn = {03600300},
journal = {ACM Computing Surveys},
keywords = {cost-benefit analysis,definitions,economics,maturity assessment,models,object-oriented,productivity,quality,reusability,reusability assessment,reuse,reuse level,reuse library metrics,software,software reuse failure modes model},
month = {jun},
number = {2},
pages = {415--435},
publisher = {ACM},
title = {{Software reuse: metrics and models}},
url = {http://portal.acm.org/citation.cfm?doid=234528.234531},
volume = {28},
year = {1996}
}

@book{Mili2002,
abstract = {1. Software reuse and software engineering -- 2. State of the art and the practice -- 3. Aspects of software reuse -- 4. Software reuse organizations -- 5. Support services -- 6. Institutionalizing reuse -- 7. Building reusable assets: an overview -- 8. Domain analysis -- 9. Programming paradigms and reusability -- 10. A pragmatic introduction to object orientation -- 11. Abstraction and parameterization techniques in object orientation -- 12. Composition techniques in object orientation -- 13. Application frameworks -- 14. Architectural frameworks -- 15. Application engineering -- 16. Component storage and retrieval -- 17. Reusable asset integration -- 18. Software reuse metrics -- 19. Software reuse cost estimation -- 20. Software reuse return on investments -- 21. Component-based software engineering (CBSE) -- 22. Product-line engineering (PLE) -- 23. COTS based development -- Appendices -- Bibliography -- Index.},
author = {Mili, Hafedh},
isbn = {0471398195},
pages = {636},
publisher = {Wiley},
title = {{Reuse based software engineering : techniques, organization and measurement}},
year = {2002}
}

@misc{Fowler2006,
author = {Fowler, Martin},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
title = {{Continuous Integration}},
howpublished = "\url{http://martinfowler.com/articles/continuousIntegration.html}",
urldate = {2016-09-11},
note = "Accessed: 11.09.2016",
year = {2006}
}

@article{Rejstrom2016,
author = {Rejstr{\"{o}}m, Kim},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Rejstr{\"{o}}m - 2016 - Implementing Continuous Integration in a Small Company A Case Study.pdf:pdf},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
title = {{Implementing Continuous Integration in a Small Company: A Case Study}},
year = {2016}
}

@article{Rodriguez2016,
abstract = {The software intensive industry is moving towards the adoption of a value-driven and adaptive real-time business paradigm. The traditional view of software as an item that evolves through releases every few months is being replaced by the continuous evolution of software functionality. This study aims to classify and analyse the literature related to continuous deployment in the software domain in order to scope the phenomenon, provide an overview of the state-of-the-art, investigate the scientific evidence in the reported results and identify areas suitable for further research. We conducted a systematic mapping study and classified the continuous deployment literature. The benefits and challenges related to continuous deployment were also analysed. RESULTS: The systematic mapping study includes 50 primary studies published between 2001 and 2014. An in-depth analysis of the primary studies revealed ten recurrent themes that characterize continuous deployment and provide researchers with directions for future work. In addition, a set of benefits and challenges of which practitioners may take advantage were identified. CONCLUSION: Overall, although the topic area is very promising, it is still in its infancy, thus offering a plethora of new opportunities for both researchers and software intensive companies.},
author = {Rodr{\'{i}}guez, Pilar and Haghighatkhah, Alireza and Lwakatare, Lucy Ellen and Teppola, Susanna and Suomalainen, Tanja and Eskeli, Juho and Karvonen, Teemu and Kuvaja, Pasi and Verner, June M. and Oivo, Markku},
doi = {10.1016/j.jss.2015.12.015},
journal = {Journal of Systems and Software},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
pages = {263--291},
title = {{Continuous deployment of software intensive products and services: A systematic mapping study}},
volume = {123},
year = {2016}
}

@article{Mantyla2015,
author = {M{\"{a}}ntyl{\"{a}}, Mika V. and Adams, Bram and Khomh, Foutse and Engstr{\"{o}}m, Emelie and Petersen, Kai},
doi = {10.1007/s10664-014-9338-4},
file = {:Users/morph3o/Mannheim/Thesis/Papers/M{\"{a}}ntyl{\"{a}} et al. - 2015 - On rapid releases and software testing a case study and a semi-systematic literature review.pdf:pdf},
journal = {Empirical Software Engineering},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
month = {oct},
number = {5},
pages = {1384--1425},
publisher = {Springer US},
title = {{On rapid releases and software testing: a case study and a semi-systematic literature review}},
url = {http://link.springer.com/10.1007/s10664-014-9338-4},
volume = {20},
year = {2015}
}

@inproceedings{Stahl2014,
address = {New York, New York, USA},
author = {St{\aa}hl, Daniel and Bosch, Jan},
booktitle = {Companion Proceedings of the 36th International Conference on Software Engineering - ICSE Companion 2014},
doi = {10.1145/2591062.2591186},
file = {:Users/morph3o/Mannheim/Thesis/Papers/St{\aa}hl, Bosch - 2014 - Automated software integration flows in industry a multiple-case study.pdf:pdf},
isbn = {9781450327688},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
pages = {54--63},
publisher = {ACM Press},
title = {{Automated software integration flows in industry: a multiple-case study}},
url = {http://dl.acm.org/citation.cfm?doid=2591062.2591186},
year = {2014}
}

@book{Duvall2007,
abstract = {Reduce the time between when a defect is introduced and when it is fixed by integrating your software often.For any software developer who has spent days in "integration hell," cobbling together myriad software components, Continuous Integration: Improving Software Quality and Reducing Risk illustrates how to transform integration from a necessary evil into an everyday part of the development process. The key, as the authors show, is to integrate regularly and often using continuous integration (CI) practices and techniques. The authors first examine the concept of CI and its practices from the ground up and then move on to explore other effective processes performed by CI systems, such as database integration, testing, inspection, deployment, and feedback. Through more than forty CI-related practices using application examples in different languages, readers learn that CI leads to more rapid software development, produces deployable software at every step in the development lifecycle, and reduces the time between defect introduction and detection, saving time and lowering costs. With successful implementation of CI, developers reduce risks and repetitive manual processes, and teams receive better project visibility. The book coversHow to make integration a "non-event" on your software development projectsHow to reduce the amount of repetitive processes you perform when building your softwarePractices and techniques for using CI effectively with your teamsReducing the risks of late defect discovery, low quality software, lack of visibility, and lack of deployable softwareAssessments of different CI servers and related tools on the marketThe book's companion Web site, www.integratebutton.com, provides updates and code examples.},
author = {Duvall, Paul and Matyas, Steve and Glover, Andrew},
booktitle = {Book},
isbn = {9780321336385},
pages = {336},
title = {{Continuous Integration: Improving Software Quality and Reducing Risk}},
url = {http://portal.acm.org/citation.cfm?id=1406212},
year = {2007}
}

@misc{Fowler2013,
author = {Fowler, Martin},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
title = {{Continuous Delivery}},
howpublished = "\url{https://martinfowler.com/bliki/ContinuousDelivery.html}",
urldate = {2017-01-09},
year = {2013},
note = "Accessed: 09.01.2017"
}

@inproceedings{Chen2015,
author = {Chen, Lianping},
booktitle = {2015 12th Working IEEE/IFIP Conference on Software Architecture},
doi = {10.1109/WICSA.2015.23},
isbn = {978-1-4799-1922-2},
month = {may},
pages = {131--134},
publisher = {IEEE},
title = {{Towards Architecting for Continuous Delivery}},
url = {http://ieeexplore.ieee.org/document/7158514/},
year = {2015}
}

@book{Poppendieck2003,
abstract = {Eliminate waste -- Amplify learning -- Decide as late as possible -- Deliver as fast as possible -- Empower the team -- Building integrity in -- See the whole -- Instructions and warranty.},
author = {Poppendieck, Mary (Mary B.) and Poppendieck, Thomas David.},
isbn = {0321150783},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
pages = {203},
publisher = {Addison-Wesley},
title = {{Lean software development : an agile toolkit}},
year = {2003}
}

@article{Laanti2011,
abstract = {CONTEXT
Many organizations have started to deploy agile methods, but so far there exist only a few studies on organization-wide transformations. Are agile methods here to stay? Some claim that agile software development methods are in the mainstream adoption phase in the software industry, while others hope that those are a passing fad. The assumption here is that if agile would not provide real improvement, adopters would be eager at first but turn pessimistic after putting it into practice. 

OBJECTIVE
Despite the growing amount of anecdotal evidence on the success of agile methods across a wide range of different real-life development settings, scientific studies remain scarce. Even less is known about the perception of the impacts of agile transformation when it is deployed in a very large software development environment, and whether agile methods are here to stay. This study aims to fill that gap by providing evidence from a large-scale agile transformation within Nokia. While we have yet to confirm these findings with solid quantitative data, we believe that the perception of the impacts already pinpoints the direction of the impacts of large-scale agile transformation. 

METHOD
The data were collected using a questionnaire. The population of the study contains more than 1000 respondents in seven different countries in Europe, North America, and Asia. 

RESULTS
The results reveal that most respondents agree on all accounts with the generally claimed benefits of agile methods. These benefits include higher satisfaction, a feeling of effectiveness, increased quality and transparency, increased autonomy and happiness, and earlier detection of defects. Finally, 60{\%} of respondents would not like to return to the old way of working. 

CONCLUSION
While the perception of the impact of agile methods is predominantly positive, several challenge areas were discovered. However, based on this study, agile methods are here to stay.},
author = {Laanti, Maarit and Salo, Outi and Abrahamsson, Pekka},
doi = {10.1016/j.infsof.2010.11.010},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Laanti, Salo, Abrahamsson - 2011 - Agile methods rapidly replacing traditional methods at Nokia A survey of opinions on agile transforma.pdf:pdf},
journal = {Information and Software Technology},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
number = {3},
pages = {276--290},
title = {{Agile methods rapidly replacing traditional methods at Nokia: A survey of opinions on agile transformation}},
volume = {53},
year = {2011}
}

@article{Leppanen2015,
author = {Leppanen, Marko and Makinen, Simo and Pagels, Max and Eloranta, Veli-Pekka and Itkonen, Juha and Mantyla, Mika V. and Mannisto, Tomi},
doi = {10.1109/MS.2015.50},
journal = {IEEE Software},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
month = {mar},
number = {2},
pages = {64--72},
title = {{The highways and country roads to continuous deployment}},
url = {http://ieeexplore.ieee.org/document/7057604/},
volume = {32},
year = {2015}
}

@inproceedings{Neely2013,
author = {Neely, Steve and Stolt, Steve},
booktitle = {2013 Agile Conference},
doi = {10.1109/AGILE.2013.17},
isbn = {978-0-7695-5076-3},
keywords = {continuous integration},
mendeley-tags = {continuous integration},
month = {aug},
pages = {121--128},
publisher = {IEEE},
title = {{Continuous Delivery? Easy! Just Change Everything (Well, Maybe It Is Not That Easy)}},
url = {http://ieeexplore.ieee.org/document/6612887/},
year = {2013}
}

@book{Humble2010,
abstract = {One of the major aims of this book is to improve collaboration between the people responsible for delivering software. In particular, we have in mind developers, testers, systems and database administrators, and managers. We cover topics from traditional configuration management, source code control, release planning, auditing, compliance, and integration to the automation of your building, testing, and deployment processes. We also describe techniques such as automated acceptance testing, dependency management, database migration, and the creation and management of testing and production environments. Many people involved in creating software consider these activities secondary to writing code. However, in our experience they take up a great deal of time and effort, and are critical to successful software delivery. When the risks surrounding these activities are not managed adequately, they can end up costing a lot of money, often more than the cost of building the software in the first place.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Humble, Jezz and Farley, David},
booktitle = {Continuous delivery},
doi = {10.1007/s13398-014-0173-7.2},
eprint = {arXiv:1011.1669v3},
isbn = {978-0-321-60191-9},
issn = {1098-6596},
pages = {497},
pmid = {25246403},
title = {{Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation}},
year = {2010}
}

@book{Booch2007,
abstract = {In this eagerly awaited second edition, Grady Booch draws upon the rich and varied results of those projects and offers improved methods for object development and a new, unified notation. With numerous examples implemented in C++, Booch illustrates essential concepts, explains the method, and shows successful applications in a variety of fields. Booch also gives pragmatic advice on a host of issues, including classification, implementation strategies, and cost-effective project management. A two-time winner of Software Development's coveted Jolt Cola Product Excellence Award!},
author = {Booch, Grady and Maksimchuk, Robert a. and Engle, Michael W. and Young, Bobbi J. and Conallen, Jim and Houston, Kelli a.},
booktitle = {Chemistry {\&} biodiversity},
doi = {10.1145/1402521.1413138},
isbn = {020189551X},
issn = {14337851},
number = {11},
pages = {720},
title = {{Object-Oriented Analysis and Design with Applications}},
volume = {1},
year = {2007}
}

@book{Beck1999,
abstract = {Kent Beck's eXtreme Programming eXplained provides an intriguing high-level overview of the author's Extreme Programming (XP) software development methodology. Written for IS managers, project leaders, or programmers, this guide provides a glimpse at the principles behind XP and its potential advantages for small- to mid-size software development teams. The book intends to describe what XP is, its guiding principles, and how it works. Simply written, the book avoids case studies and concrete details in demonstrating the efficacy of XP. Instead, it demonstrates how XP relies on simplicity, unit testing, programming in pairs, communal ownership of code, and customer input on software to motivate code improvement during the development process. As the author notes, these principles are not new, but when they're combined their synergy fosters a new and arguably better way to build and maintain software. Throughout the book, the author presents and explains these principles, such as "rapid feedback" and "play to win," which form the basis of XP. Generally speaking, XP changes the way programmers work. The book is good at delineating new roles for programmers and managers who Beck calls "coaches." The most striking characteristic of XP is that programmers work in pairs, and that testing is an intrinsic part of the coding process. In a later section, the author even shows where XP works and where it doesn't and offers suggestions for migrating teams and organizations over to the XP process. In the afterword, the author recounts the experiences that led him to develop and refine XP, an insightful section that should inspire any organization to adopt XP. This book serves as a useful introduction to the philosophy and practice of XP for the manager or programmer who wants a potentially better way to build software. -Richard Dragan Topics covered: Extreme Programming (XP) software methodology, principles, XP team roles, facilities design, testing, refactoring, the XP software lifecycle, and adopting XP. Software development projects can be fun, productive, and even daring. Yet they can consistently deliver value to a business and remain under control. Extreme Programming (XP) was conceived and developed to address the specific needs of software development conducted by small teams in the face of vague and changing requirements. This new lightweight methodology challenges many conventional tenets, including the long-held assumption that the cost of changing a piece of software necessarily rises dramatically over the course of time. XP recognizes that projects have to work to achieve this reduction in cost and exploit the savings once they have been earned. Fundamentals of XP include: Distinguishing between the decisions to be made by business interests and those to be made by project stakeholders. Writing unit tests before programming and keeping all of the tests running at all times. Integrating and testing the whole system-several times a day. Producing all software in pairs, two programmers at one screen. Starting projects with a simple design that constantly evolves to add needed flexibility and remove unneeded complexity. Putting a minimal system into production quickly and growing it in whatever directions prove most valuable. Why is XP so controversial? Some sacred cows don't make the cut in XP: Don't force team members to specialize and become analysts, architects, programmers, testers, and integrators-every XP programmer participates in all of these critical activities every day. Don't conduct complete up-front analysis and design-an XP project starts with a quick analysis of the entire system, and XP programmers continue to make analysis and design decisions throughout development. Develop infrastructure and frameworks as you develop your application, not up-front-delivering business value is the heartbeat that drives XP projects. Don't write and maintain implementation documentation-communication in XP projects occurs face-to-face, or through efficient tests and carefully written code. You may love XP or you may hate it, but Extreme Programming Explained will force you to take a fresh look at how you develop software.},
archivePrefix = {arXiv},
arxivId = {0201616416},
author = {Beck, Kent},
booktitle = {XP Series},
doi = {10.1136/adc.2005.076794},
eprint = {0201616416},
isbn = {0201616416},
issn = {20161641},
number = {c},
pages = {224},
pmid = {17337672},
title = {{Extreme Programming Explained: Embrace Change}},
year = {1999}
}

@article{Hummel2008,
author = {Hummel, Oliver and Janjic, Werner and Atkinson, Colin},
doi = {10.1109/MS.2008.110},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Hummel, Janjic, Atkinson - 2008 - Code Conjurer Pulling Reusable Software out of Thin Air.pdf:pdf},
issn = {0740-7459},
journal = {IEEE Software},
keywords = {Acceleration,Application software,Assembly,Computer industry,Computer languages,Eclipse plug-in,IT industry,Java,Programming,Software reusability,Software systems,Web services,code conjurer,component-based development,component-based reuse,object-oriented programming,open source software,programming language,reusable software,reuse recommendation,software assets,software development,software functionality,software reusability,software reuse,software search engines,test-driven search},
mendeley-tags = {software reuse},
month = {sep},
number = {5},
pages = {45--52},
publisher = {IEEE},
title = {{Code Conjurer: Pulling Reusable Software out of Thin Air}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4602673},
volume = {25},
year = {2008}
}

@article{Lemos2007,
abstract = {We present CodeGenie, a tool that implements a test-driven approachto search and reuse of code available on large-scale coderepositories. While using CodeGenie developers design test cases fora desired feature first, similar to Test-driven Development (TDD).However, instead of implementing the feature as in TDD, CodeGenieautomatically searches for it based on information available in thetests. To check the suitability of the candidate results in thelocal context, each result is automatically woven into thedeveloper's project and tested using the original tests. Thedeveloper can then reuse the most suitable result. Later, reusedcode can also be unwoven from the project as wished. For the codesearching and wrapping facilities, CodeGenie relies on Sourcerer, anInternet-scale source code infrastructure that we have developed},
author = {Lemos, Ot{\'{a}}vio Augusto Lazzarini and Bajracharya, Sushil Krishna and Ossher, Joel},
doi = {10.1145/1321631.1321726},
isbn = {9781595938824},
journal = {OOPSLA 2007},
keywords = {1,driven development,have limited features and,in particular,search effectiveness,source code reuse,source code search,support for integration of,test-,test-first,there is no strong,these search},
pages = {525--526},
title = {{CodeGenie: a Tool for Test-Driven Source Code Search}},
url = {http://portal.acm.org/citation.cfm?id=1321631.1321726},
volume = {07pp},
year = {2007}
}

@article{Thummalapenta2007,
abstract = {Abbreviation Completion is a novel technique to improve the efficiency of code-writing by supporting code completion of multiple keywords based on non-predefined abbreviated input—a different approach from conventional code completion that finds one keyword at a time based on an exact character match. Abbreviated input is expanded into keywords by a Hidden Markov Model learned from a corpus of existing code. The technique does not require the user to memorize abbreviations and provides incremental feedback of the most likely completions. This paper presents the algorithm for abbreviation completion, integrated with a new user interface for multiple-keyword completion. We tested the system by sampling 3000 code lines from open source projects and found that more than 98{\%} of the code lines could be resolved from acronym-like abbreviations. A user study found 30{\%} reduction in time usage and 41{\%} reduction of keystrokes over conventional code completion. Code Completion; Hidden Ma},
author = {Thummalapenta, Suresh and Xie, Tao},
doi = {10.1145/1321631.1321663},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Thummalapenta, Xie - Unknown - PARSEWeb A Programmer Assistant for Reusing Open Source Code on the Web.pdf:pdf},
isbn = {9781595938824},
issn = {03621340},
journal = {Proceedings of the twenty-second IEEE/ACM international conference on Automated software engineering},
keywords = {code exam-,code examples,code reuse,code search engine,ples,ranking code samples,software reuse},
mendeley-tags = {software reuse},
pages = {204--213},
title = {{Parseweb: a programmer assistant for reusing open source code on the web}},
url = {http://dl.acm.org/citation.cfm?id=1321663},
year = {2007}
}

@incollection{Hummel2013,
address = {New York, NY},
author = {Hummel, Oliver and Janjic, Werner},
booktitle = {Finding Source Code on the Web for Remix and Reuse},
doi = {10.1007/978-1-4614-6596-6_12},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Hummel, Janjic - 2013 - Test-Driven Reuse Key to Improving Precision of Search Engines for Software Reuse.pdf:pdf},
pages = {227--250},
publisher = {Springer New York},
title = {{Test-Driven Reuse: Key to Improving Precision of Search Engines for Software Reuse}},
url = {http://link.springer.com/10.1007/978-1-4614-6596-6{\_}12},
year = {2013}
}

@article{Pole1994,
abstract = {An empirical study of methods for representing reusable software components is described. Thirty-five subjects searched for reusable components in a database of UNIX tools using four different representation methods: attribute-value, enumerated, faceted, and keyword. The study used Proteus, a reuse library system that supports multiple representation methods. Searching effectiveness was measured with recall, precision, and overlap. Search time for the four methods was also compared. Subjects rated the methods in terms of preference and helpfulness in understanding components. Some principles for constructing reuse libraries. Based on the results of this study, are discussed},
author = {Pole, Thomas P. and Frakes, W.B.},
doi = {10.1109/32.310671},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Software reuse,component indexing,component understanding,database,empirical,enumerated classification,experimentation,faceted classification,information storage and retrieval,keyword searching,methods,reuse libraries},
number = {8},
pages = {617--630},
title = {{An Empirical Study of Representation Methods for Reusable Software Components}},
volume = {20},
year = {1994}
}

@article{Seacord1999,
author = {Seacord, RC},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Seacord - 1999 - Software engineering component repositories.pdf:pdf},
journal = {Proceedings of the International Workshop on},
title = {{Software engineering component repositories}},
url = {http://faculty.ksu.edu.sa/ghazy/CBD{\_}MSc/Ref-25.pdf{\#}page=95},
year = {1999}
}

@inproceedings{Garcia2006,
author = {Garcia, Vinicius C. and de Almeida, Eduardo S. and Lisboa, Liana B. and Martins, Alexandre C. and Meira, Silvio R. L. and Lucredio, Daniel and Fortes, Renata P. de M.},
booktitle = {2006 13th Asia Pacific Software Engineering Conference (APSEC'06)},
doi = {10.1109/APSEC.2006.57},
isbn = {0-7695-2685-3},
pages = {61--70},
publisher = {IEEE},
title = {{Toward a Code Search Engine Based on the State-of-Art and Practice}},
url = {http://ieeexplore.ieee.org/document/4137403/},
year = {2006}
}

@article{Prieto-Diaz1987,
abstract = {To reuse a software component, you first have to find it. The faceted scheme described here is a partial solution to this classification and retrieval problem.},
author = {Prieto-D{\'{i}}az, Rub{\'{e}}n and Freeman, Peter},
doi = {10.1109/MS.1987.229789},
issn = {07407459},
journal = {IEEE Software},
number = {1},
pages = {6--16},
title = {{Classifying Software for Reusability}},
volume = {4},
year = {1987}
}

@article{Inoue2005,
abstract = { Collections of already developed programs are important resources for efficient development of reliable software systems. In this paper, we propose a novel graph-representation model of a software component library (repository), called component rank model. This is based on analyzing actual usage relations of the components and propagating the significance through the usage relations. Using the component rank model, we have developed a Java class retrieval system named SPARS-J and applied SPARS-J to various collections of Java files. The result shows that SPARS-J gives a higher rank to components that are used more frequently. As a result, software engineers looking for a component have a better chance of finding it quickly. SPARS-J has been used by two companies, and has produced promising results.},
author = {Inoue, Katsuro and Yokomori, Reishi and Yamamoto, Tetsuo and Matsushita, Makoto and Kusumoto, Shinji},
doi = {10.1109/TSE.2005.38},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Component rank,Graph representation model,Program analysis,Reusable libraries,Reuse models},
number = {3},
pages = {213--225},
title = {{Ranking significance of software components based on use relations}},
volume = {31},
year = {2005}
}

@incollection{Hummel2013B,
address = {New York, NY},
author = {Hummel, Oliver and Atkinson, Colin and Schumacher, Marcus},
booktitle = {Finding Source Code on the Web for Remix and Reuse},
doi = {10.1007/978-1-4614-6596-6_5},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Hummel, Atkinson, Schumacher - 2013 - Artifact Representation Techniques for Large-Scale Software Search Engines.pdf:pdf},
pages = {81--101},
publisher = {Springer New York},
title = {{Artifact Representation Techniques for Large-Scale Software Search Engines}},
url = {http://link.springer.com/10.1007/978-1-4614-6596-6{\_}5},
year = {2013}
}

@misc{lucene,
author = {The Apache Software Foundation},
title = {{Apache Lucene - Apache Lucene Core}},
howpublished = "\url{https://lucene.apache.org/core/}",
urldate = {2017-01-12},
year = {2017},
note = "Accessed: 12.01.2017"
}

@misc{Horowitz2011,
author = {Horowitz, Bradley},
title = {{Official Google Blog: A fall sweep}},
howpublished = "\url{https://googleblog.blogspot.cl/2011/10/fall-sweep.html}",
urldate = {2017-01-12},
year = {2011},
note = "Accessed: 12.01.2017"
}

@article{Bauer2016,
abstract = {CONTEXT Reuse can improve productivity and maintainability in software development. Research has proposed a wide range of methods and techniques. Are these successfully adopted in practice? OBJECTIVE We propose a preliminary answer by integrating two in-depth empirical studies on software reuse at two large software-producing companies. METHOD We compare and interpret the study results with a focus on reuse practices, effects, and context. RESULTS Both companies perform pragmatic reuse of code produced within the company, not leveraging other available artefacts. Reusable entities are retrieved from a central repository, if present. Otherwise, direct communication with trusted colleagues is crucial for access. Reuse processes remain implicit and reflect the development style. In a homogeneous infrastructure-supported context, participants strongly agreed on higher development pace and less maintenance effort as reuse benefits. In a heterogeneous context with fragmented infrastructure, these benefits did not materialize. Neither case reports statistically significant evidence of negative side effects of reuse nor inhibitors. In both cases, a lack of reuse led to duplicate implementations. CONCLUSION Technological advances have improved the way reuse concepts can be applied in practice. Homogeneity in development process and tool support seem necessary preconditions. Developing and adopting adequate reuse strategies in heterogeneous contexts remains challenging.},
author = {Bauer, Veronika and Vetro', Antonio},
doi = {10.1016/j.jss.2016.03.067},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Bauer, Vetro' - 2016 - Comparing reuse practices in two large software-producing companies.pdf:pdf;:Users/morph3o/Mannheim/Thesis/Papers/Bauer, Vetro' - 2016 - Comparing reuse practices in two large software-producing companies(2).pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {software reuse},
mendeley-tags = {software reuse},
pages = {545--582},
title = {{Comparing reuse practices in two large software-producing companies}},
volume = {117},
year = {2016}
}

@article{Morisio2002,
author = {Morisio, M. and Ezran, M. and Tully, C.},
doi = {10.1109/TSE.2002.995420},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
month = {apr},
number = {4},
pages = {340--357},
title = {{Success and failure factors in software reuse}},
url = {http://ieeexplore.ieee.org/document/995420/},
volume = {28},
year = {2002}
}

@article{Standish1984,
abstract = {This paper explores software reuse. It discusses briefly some economic incentives for developing effective software reuse technology and notes that different kinds of software reuse, such as direct use without modification and reuse of abstract software modules after refinement, have different technological implications. It sketches some problem areas to be addressed if we are to achieve the goal of devising practical software reuse systems. These include information retrieval problems and finding effective methods to aid us in understanding how programs work. There is a philosophical epilogue which stresses the importance of having realistic expectations about the benefits of software reuse.},
author = {Standish, Thomas A.},
doi = {10.1109/TSE.1984.5010272},
isbn = {0098-5589},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Index Terms,Software factories,software productivity,software reuse},
number = {5},
pages = {494--497},
title = {{An Essay on Software Reuse}},
volume = {SE-10},
year = {1984}
}

@article{Chacon2009,
abstract = {Git is the version control system developed by Linus Torvalds for Linux kernel development. It took the open source world by storm since its inception in 2005, and is used by small development shops and giants like Google, Red Hat, and IBM, and of course many open source projects.  A book by Git experts to turn you into a Git expert  Introduces the world of distributed version control  Shows how to build a Git development workflow   What you'll learn Use Git as a programmer or a project leader Become a fluent Git user Use distributed features of Git to the full Acquire the ability to insert Git in the development workflow Migrate programming projects from other SCMs to Git Learn how to extend Git  Who this book is for  This book is for all open source developers: you are bound to encounter Git somewhere in the course of your working life. Proprietary software developers will appreciate Git's enormous scalability, since it is used for the Linux project, which comprises thousands of developers and testers.  Table of Contents Getting Started  Git Basics  Git Branching  Git on the Server  Distributed Git  Git Tools  Customizing Git  Git and Other Systems  Git Internals},
archivePrefix = {arXiv},
arxivId = {arXiv:gr-qc/9809069v1},
author = {Chacon, Scott},
doi = {10.1007/978-1-4302-1834-0},
eprint = {9809069v1},
isbn = {978-1-4302-1833-3},
issn = {978-1-4302-1833-3},
journal = {Control},
pages = {1--210},
pmid = {10591480},
primaryClass = {arXiv:gr-qc},
title = {{Pro Git}},
url = {http://www.springerlink.com/index/10.1007/978-1-4302-1834-0{\$}{\%}5C{\$}nhttp://books.google.com/books?hl=en{\%}7B{\%}7B{\%}7D{\%}7B{\&}{\%}7D{\%}7B{\%}7D{\%}7Damp;lr={\%}7B{\%}7B{\%}7D{\%}7B{\&}{\%}7D{\%}7B{\%}7D{\%}7Damp;id=qJsXefpx1AUC{\%}7B{\%}7B{\%}7D{\%}7B{\&}{\%}7D{\%}7B{\%}7D{\%}7Damp;oi=fnd{\%}7B{\%}7B{\%}7D{\%}7B{\&}{\%}7D{\%}7B{\%}7D{\%}7Damp;pg=PR14{\%}7B{\%}7B{\%}7D{\%}7B{\&}{\%}7D{\%}7B{\%}7D{\%}7Damp;dq=pro+Git{\%}7B{\%}7B{\%}7D{\%}7B{\&}{\%}7D{\%}7B{\%}7D{\%}7Damp;ots=jPHxpHDZKg{\%}7B{\%}7B{\%}7D{\%}7B{\&}{\%}7D{\%}7B{\%}7D{\%}7Damp;sig=kbOrJBU},
year = {2009}
}

@misc{Weis2014,
author = {Weis, Kristina},
title = {{GitHub CEO and Co-Founder Chris Wanstrath Keynoting Esri's DevSummit! | ArcGIS Blog}},
howpublished = "\url{https://goo.gl/or7oIX}",
urldate = {2017-01-14},
note = "Accessed: 14.01.2017",
year = {2014}
}

@inproceedings{Hummel2004,
abstract = {The reuse of software components is the key to improving productivity and quality levels in software engineering. However, although the technologies for plugging together components have evolved dramatically over the last few years (e.g. EJB, .NET, Web Services) the technologies for actually finding them in the first place are still relatively immature. In this paper we present a simple but effective approach for harvesting software components from the Internet. The initial discovery of components is achieved using a standard web search engine such as Google, and the evaluation of "fitness for purpose" is performed by automated testing. Since test-driven evaluation of software is the hallmark of Extreme Programming, and the approach naturally complements the extreme approach to software engineering, we refer to it as "Extreme Harvesting". The paper first explains the principles behind Extreme Harvesting and then describes a prototype implementation. {\textcopyright} 2004 IEEE.},
author = {Hummel, Oliver and Atkinson, Colin},
booktitle = {Proceedings of the 2004 IEEE International Conference on Information Reuse and Integration, IRI-2004},
doi = {10.1109/IRI.2004.1431438},
isbn = {0780388194},
pages = {66--72},
title = {{Extreme harvesting: Test driven discovery and reuse of software components}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-16244403981{\&}partnerID=tZOtx3y1},
year = {2004}
}

@article{Mili1998,
abstract = {The study of storage and retrieval methods of software assets in software libraries gives rise to a number of paradoxes: While this subject has been under investigation for nearly two decades, it still remains an active area of research in software reuse and software engineering; this can be explained by the observation that new technologies (such as the internet, the world wide web, object-;oriented programming) keep opening new opportunities for better asset packaging, better library organizations, and larger scale libraries – thereby posing new technical challenges. Also, while many sophisticated solutions have been proposed to this problem, the state of the practice in software reuse is characterized by the use of ad-;hoc, low-;tech methods; this can be explained by the observation that most existing solutions are either too ineffective to be useful or too intractable to be usable. Finally, while it is difficult to imagine a successful software reuse program without a sophisticated, well-;tuned, systematic procedure for software component storage and retrieval, it seems many successful software reuse experiments rely on trivial methods of component storage and retrieval; this can be explained by the observation that, in the current state of the practice, software libraries are not the bottleneck of the software reuse process. This paper presents a survey of methods of storage and retrieval of software assets in software libraries. In addition to a review of existing research efforts, the paper makes two contributions. First, a definition of (presumably) orthogonal attributes of storage and retrieval methods; these attributes are used, in turn, to classify existing methods into six broad classes. Second, a definition of (presumably) orthogonal assessment criteria, which include technical, managerial and human factors; these criteria afford us an exhaustive and uniform basis for assessing and comparing individual methods and classes of methods.},
author = {Mili, a. and Mili, R. and Mittermeir, R.T.},
doi = {10.1023/A:1018964121953},
issn = {1022-7091},
journal = {Annals of Software Engineering},
keywords = {Computer Science},
number = {1},
pages = {349--414--414},
title = {{A survey of software reuse libraries}},
url = {http://www.springerlink.com/content/u7j724230tn12h03/},
volume = {5},
year = {1998}
}

@inproceedings{Hummel2007,
abstract = {Component-based software reuse has long been seen as a means of improving the efficiency of software development projects and the resulting quality of software systems. However, in practice it has proven difficult to set up and maintain viable software repositories and provide effective mechanisms for retrieving components and services from them. Although the literature contains a comprehensive collection of retrieval methods, to date there have been few evaluations of their relative efficiency. Moreover, those that are available only study small repositories of about a few hundred components. Since today's internet-based repositories are many orders of magnitude larger they require much higher search precision to deliver usable results. In this paper we present an evaluation of well known component retrieval techniques in the context of modern component repositories available on the World Wide Web. Copyright {\textcopyright} (2007) by Knowledge Systems Institute (KSI).},
author = {Hummel, Oliver and Janjic, Werner and Atkinson, Colin},
booktitle = {19th International Conference on Software Engineering and Knowledge Engineering, SEKE 2007},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Hummel, Janjic, Atkinson - Unknown - Evaluating the Efficiency of Retrieval Methods for Component Repositories.pdf:pdf},
isbn = {9781627486613 (ISBN)},
keywords = {Component based software,Component repository,Component retrieval,Computer software reusability,Effective mechanisms,Efficiency,Information retrieval,Knowledge engineering,Quality of softwares,Relative efficiency,Software development projects,Software engineering,Software repositories,World Wide Web},
pages = {404--409},
title = {{Evaluating the efficiency of retrieval methods for component repositories}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-84885874577{\&}partnerID=40{\&}md5=721d5655d6d965ca8983f75687753531},
year = {2007}
}

@inproceedings{Reiss2009,
abstract = {Our goal is to use the vast repositories of available open source code to generate specific functions or classes that meet a user's specifications. The key words here are specifications and generate. We let users specify what they are looking for as precisely as possible using keywords, class or method signatures, test cases, contracts, and security constraints using a simple, Web-based interface. Our system then uses an open set of program transformations to map retrieved code into what the user asked for. This approach is implemented in a prototype system for Java with a Web interface.},
author = {Reiss, Steven P.},
booktitle = {Proceedings - International Conference on Software Engineering},
doi = {10.1109/ICSE.2009.5070525},
isbn = {9781424434527},
issn = {02705257},
pages = {243--253},
title = {{Semantics-based code search}},
year = {2009}
}

@article{Beck2003,
abstract = {Write clean code that works with the help of this groundbreaking software method. Example-driven teaching is the basis of Beck's step-by-step instruction that will have readers using TDD to further their projects.},
author = {Beck, Kent},
doi = {10.5381/jot.2003.2.2.r1},
isbn = {0321146530},
issn = {1660-1769},
journal = {Rivers},
number = {c},
pages = {176},
title = {{Test-Driven Development By Example}},
url = {http://books.google.com/books?hl=en{\&}lr={\&}id=goE1TL0u0dUC{\&}oi=fnd{\&}pg=PR9{\&}dq=Test-Driven+Development+By+Example{\&}ots=I9zvvKjuGi{\&}sig=zSDvHh2aa5OrmQcVh7ppTTR5CKE},
volume = {2},
year = {2003}
}

@article{Stolee2016,
abstract = {In this work we generalize, improve, and extensively assess our semantic source code search engine through which developers use an input/output query model to specify what behavior they want instead of how it may be implemented. Under this approach a code repository contains programs encoded as constraints and an SMT solver finds encoded programs that match an input/output query. The search engine returns a list of source code snippets that match the specification. The initial instantiation of this approach showed potential but was limited. It only encoded single-path programs, reported just complete matches, did not rank the results, and was only partly assessed. In this work, we explore the use of symbolic execution to address some of these technical shortcomings. We implemented a tool, Satsy, that uses symbolic execution to encode multi-path programs as constraints and a novel ranking algorithm based on the strength of the match between an input/output query and the program paths traversed by symbolic execution. An assessment about the relevance of Satsy's results versus other search engines, Merobase and Google, on eight novice-level programming tasks gathered from StackOverflow, using the opinions of 30 study participants, reveals that Satsy often out-performs the competition in terms of precision, and that matches are found in seconds.},
author = {Stolee, Kathryn T. and Elbaum, Sebastian and Dwyer, Matthew B.},
doi = {10.1016/j.jss.2015.04.081},
file = {:Users/morph3o/Mannheim/Thesis/Papers/Stolee, Elbaum, Dwyer - 2016 - Code search with inputoutput queries Generalizing, ranking, and assessment.pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
pages = {35--48},
title = {{Code search with input/output queries: Generalizing, ranking, and assessment}},
volume = {116},
year = {2016}
}

@misc{Docker,
title = {{The Docker Platform}},
howpublished = "\url{https://www.docker.com}",
urldate = {2017-01-19},
note = "Accessed: 19.01.2017",
year = {2017},
author = {Docker Inc.},
}

@techreport{rfc2045,
   AUTHOR = {Ned Freed and Nathaniel Borenstein},
   TITLE = "{Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies}",
   HOWPUBLISHED = {Internet Requests for Comments},
   TYPE="{RFC}",
   NUMBER=2054,
   PAGES = {1-31},
   YEAR = {1996},
   MONTH = {November},
   PUBLISHER = "{The Internet Engineering Task Force (IETF)}",
   INSTITUTION = "{The Internet Engineering Task Force (IETF)}",
   URL={https://www.ietf.org/rfc/rfc2045.txt}
   }
   
@misc{Fowler2014,
abstract = {The term "Microservice Architecture" has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architectural style, there are certain common characteristics around organization around business capability, automated deployment, intelligence in the endpoints, and decentralized control of languages and data.},
author = {Fowler, Martin and Lewis, James},
title = {{Microservices}},
howpublished = "\url{https://martinfowler.com/articles/microservices.html}",
urldate = {2017-02-02},
year = {2014}
}

@misc{Leberknight2008,
author = {Leberknight, Scott},
title = {{Polyglot Persistence}},
howpublished = "\url{http://www.sleberknight.com/blog/sleberkn/entry/polyglot_persistence}",
urldate = {2017-02-03},
note = "Accessed: 03.02.2017", 
year = {2008}
}

@misc{Fowler2011,
author = {Fowler, Martin},
title = {{Polyglot Persistence}},
howpublished = "\url{https://martinfowler.com/bliki/PolyglotPersistence.html}",
urldate = {2017-02-03},
note = "Accessed: 03.02.2017",
year = {2011}
}